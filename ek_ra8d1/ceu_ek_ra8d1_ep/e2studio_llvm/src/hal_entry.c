/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Entry function.
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
 * applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
 * this software. By using this software, you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 *
 * Copyright (C) 2023 Renesas Electronics Corporation. All rights reserved.
 ***********************************************************************************************************************/
#include <ov7725.h>
#include "hal_data.h"
#include "common_utils.h"
#include "gt911.h"
#include "mipi_dsi_ep.h"
#include "ceu.h"
#include "Graphics\graphics.h"

#include "ov5640.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

extern const sensor_reg_t g_ov3640_vga[];

uint8_t g_image_vga_sram [ VGA_WIDTH * VGA_HEIGHT * YUV422_BYTE_PER_PIXEL ]  BSP_PLACE_IN_SECTION(".sdram") BSP_ALIGN_VARIABLE(8);
//uint8_t g_image_rgb888_sdram_buffer [ VGA_WIDTH  * VGA_HEIGHT * RGB888_BYTE_PER_PIXEL ] BSP_PLACE_IN_SECTION(".sdram") BSP_ALIGN_VARIABLE(8);
uint8_t g_image_rgb565_sdram_buffer [ VGA_WIDTH  * VGA_HEIGHT * RGB565_BYTE_PER_PIXEL ] BSP_PLACE_IN_SECTION(".sdram") BSP_ALIGN_VARIABLE(8);

volatile bool g_message_sent;
volatile mipi_dsi_phy_status_t g_phy_status;

static volatile i2c_master_event_t i2c_master_event = 0;
static volatile bool g_vsync_flag, g_irq_state  = RESET_FLAG;

static uint32_t * gp_frame_buffer  = NULL;

volatile uint16_t fps_temp = 0, fps_mipi_ceu = 0;
//bool gpio_level=0;
uint8_t timer_counter=0;

void draw_fps_text();
void draw_fps_number(uint8_t place, uint8_t value);

/* Callback function */
void timer0_100ms_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
//    gpio_level = !gpio_level;
//    R_BSP_PinWrite(BSP_IO_PORT_08_PIN_13, (bsp_io_level_t)gpio_level);
    timer_counter++;
    if(timer_counter>=10)
    {
        timer_counter = 0;
        fps_mipi_ceu = fps_temp;
        fps_temp = 0;
    }
}

void update_fps_counter(float fps);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};
    uint8_t StatusRegister = RESET_VALUE;
    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Initialize SDRAM. */
    bsp_sdram_init();

    err = R_GLCDC_Open(&g_display_ctrl, &g_display_cfg);
       if (FSP_SUCCESS != err)
       {
           __BKPT(0);
       }
       err = R_GLCDC_Start(&g_display_ctrl);

    /* Initialize MIPI DSI module */
    err = R_MIPI_DSI_Open(&g_mipi_dsi0_ctrl, &g_mipi_dsi0_cfg);
    /* Handle error */
    handle_error(err, "** MIPI DSI driver initialization FAILED ** \r\n");

    /* Initialize IIC MASTER module */
    err = R_IIC_MASTER_Open(&g_i2c_master_ctrl, &g_i2c_master_cfg);
    /* Handle error */
    handle_error(err, "** IIC MASTER Open API failed ** \r\n");

    /* Initialize ICU module */
    err = R_ICU_ExternalIrqOpen(&g_touch_external_irq_ctrl, &g_touch_external_irq_cfg);
    /* Handle error */
    handle_error(err, "** ICU ExternalIrqOpen API failed ** \r\n");

#if 0
    /* Initialize OV7725 camera sensor */
    err = ov7725_open();
    /* Handle error */
    handle_error(err, "** ov7725_open API failed ** \r\n");

    OV7725_Window_Set(VGA_WIDTH, VGA_HEIGHT, 1);
#else
	/* Initialize OV5640 camera sensor */
    ov5640_init();
    ov5640_set_output_format(OV5640_OUTPUT_FORMAT_RGB565);
    ov5640_auto_focus_init();
//    ov5640_set_test_pattern(OV5640_TEST_PATTERN_COLOR_BAR);
    ov5640_set_output_size(VGA_WIDTH,VGA_HEIGHT);
    ov5640_set_exposure_level(OV5640_EXPOSURE_LEVEL_8);
#endif

    err = ceu_init(g_image_vga_sram, VGA_WIDTH, VGA_HEIGHT);
    /* Handle error */
    handle_error(err, "** ceu_init API failed ** \r\n");

    /* LCD reset */
    touch_screen_reset();

    /* Initialize LCD. */
    mipi_dsi_push_table(g_lcd_init_focuslcd);

    graphics_init();

    /* Start display 8-color bars */
    mipi_dsi_start_display();

//    R_BSP_PinAccessEnable();
//
//    R_BSP_PinWrite(BSP_IO_PORT_08_PIN_13, (bsp_io_level_t)0);

    R_AGT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    R_AGT_Start(&g_timer0_ctrl);

    while (true)
    {

            fps_temp++;
            update_fps_counter(fps_mipi_ceu);

            /* Swap the active framebuffer */
            gp_frame_buffer = (gp_frame_buffer == gp_single_buffer) ? gp_double_buffer : gp_single_buffer;

            err = ceu_operation(g_image_vga_sram);
            /* Handle error */
            handle_error(err, "** ceu_operation API failed ** \r\n");


#if(0)  //If format out is YUV, use this conversion function
            yuv422_to_rgb565(&g_image_vga_sram[0], &g_image_rgb565_sdram_buffer[0], VGA_WIDTH, VGA_HEIGHT);
            graphics_draw_frame(&g_image_rgb565_sdram_buffer[0], (uint8_t*) gp_frame_buffer, VGA_WIDTH, VGA_WIDTH, VGA_HEIGHT);
#else
            graphics_draw_frame(&g_image_vga_sram[0], (uint8_t*) gp_frame_buffer, VGA_WIDTH, VGA_WIDTH, VGA_HEIGHT);
#endif

            /* Now that the framebuffer is ready, update the GLCDC buffer pointer on the next Vsync */
            err = R_GLCDC_BufferChange (&g_display_ctrl, (uint8_t*) gp_frame_buffer, DISPLAY_FRAME_LAYER_1);
            handle_error (err, "** GLCD BufferChange API failed ** \r\n");
            /* Wait for a Vsync event */
            g_vsync_flag = RESET_FLAG;

    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief       This function is used to Wait for i2c event.
 *
 * @param[in]   event       : Events to look forward to
 * @retval      FSP_SUCCESS : Upon successful operation, otherwise: failed
 **********************************************************************************************************************/
fsp_err_t wait_for_i2c_event (i2c_master_event_t set_event)
{
    uint32_t timeout = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_ICLK) / 10;
    uint32_t get_event;

    do
    {
        get_event = i2c_master_event;
        get_event = (set_event & get_event);
        if(get_event)
        {
            i2c_master_event &= (~set_event);
            break;
        }
    }while(timeout--);

    return timeout ? FSP_SUCCESS : FSP_ERR_TIMEOUT;
}

/*******************************************************************************************************************//**
 * @brief      Callback functions for i2c master interrupts
 *
 * @param[in]  p_args    Callback arguments
 * @retval     none
 **********************************************************************************************************************/
void g_i2c_master_callback(i2c_master_callback_args_t *p_args)
{
    if (NULL != p_args)
    {
        i2c_master_event |= p_args->event;
    }
}

/*******************************************************************************************************************//**
 * @brief      Touch IRQ callback function
 * NOTE:       This function will return to the highest priority available task.
 * @param[in]  p_args  IRQ callback data
 * @retval     None.
 **********************************************************************************************************************/
void touch_external_irq_callback(external_irq_callback_args_t *p_args)
{
    if (g_touch_external_irq_cfg.channel == p_args->channel)
    {
        g_irq_state = true;
    }
}

/*******************************************************************************************************************//**
 * @brief      Callback functions for GLCDC interrupts
 *
 * @param[in]  p_args    Callback arguments
 * @retval     none
 **********************************************************************************************************************/
void _DisplayVsyncCallback (display_callback_args_t * p_args)
{
    if (DISPLAY_EVENT_LINE_DETECTION == p_args->event)
    {
        g_vsync_flag = true;
    }
}

/*******************************************************************************************************************//**
 * @brief      Callback functions for MIPI DSI interrupts
 *
 * @param[in]  p_args    Callback arguments
 * @retval     none
 **********************************************************************************************************************/
void mipi_dsi0_callback(mipi_dsi_callback_args_t *p_args)
{
    switch (p_args->event)
    {
        case MIPI_DSI_EVENT_SEQUENCE_0:
        {
            if (MIPI_DSI_SEQUENCE_STATUS_DESCRIPTORS_FINISHED == p_args->tx_status)
            {
                g_message_sent = true;
            }
            break;
        }
        case MIPI_DSI_EVENT_PHY:
        {
            g_phy_status |= p_args->phy_status;
            break;
        }
        default:
        {
            break;
        }

    }
}



void update_fps_counter(float fps)
{
    if(fps >= 99.9f)
    {
        fps = 99.9f;
    }
    uint8_t hundreds = (uint8_t)(fps / 100);
    uint8_t tens = (uint8_t)(fps / 10);
    uint8_t ones = ((uint8_t)(fps) % 10);
    uint8_t decimal = (uint8_t)((uint32_t)(fps*10.0f) % 10);

    /* Number 'place' is reverse indexed */
    draw_fps_text();
    draw_fps_number(0, (0 == hundreds) ? 11 : hundreds); // Draw blank if hundreds place is zero
    draw_fps_number(1, tens);
    draw_fps_number(2, ones);
    draw_fps_number(3, 10); // Decimal point
    draw_fps_number(4, decimal);
}


#include "fps_text.c" // Number bitmap data and meta data array. 0-9 and decimal
#include "Rene.c"
#include "text_Rene.c"

void draw_fps_text()
{

//    display_input_cfg_t const *p_input = &g_mipi_dsi0_cfg.p_display_instance->p_cfg->input[1]; // Layer 2
    display_input_cfg_t const *p_input = &g_display_cfg.input[1];

    const uint8_t * p_src = Rene.pixel_data;
    uint32_t bpp = Rene.bytes_per_pixel;
    uint32_t img_width = Rene.width;
    uint32_t img_height = Rene.height;
    uint8_t * p_dest = (uint8_t*)fb_foreground;

    for(uint32_t y = 0; y<img_height; y++)
    {
        for(uint32_t h = 0; h < img_width*bpp; h+=bpp)
        {
            p_dest[0] = p_src[h+2]; // B
            p_dest[1] = p_src[h+1]; // G
            p_dest[2] = p_src[h];   // R
            p_dest[3] = 0;          // A (Unused)
            p_dest+=4;
        }
    p_dest += ((p_input->hstride - p_input->hsize) * 4); // To beginning of next line
    p_src += img_width*bpp;
    }
}

void draw_fps_number(uint8_t place, uint8_t value)
{
#define NUM_COUNT 5 // Decimal included

#include "numbers.c" // Number bitmap data and meta data array. 0-9 and decimal

    display_input_cfg_t const *p_input = &g_display_cfg.input[1];//  &g_mipi_dsi0_cfg.p_display_instance->p_cfg->input[1]; // Layer 2

    /* There are four numbers displayed with a decimal point, so 5 characters in all
     * Each row of pixels will be offset by the count of numbers before it */
    const uint8_t * p_src = numbers[value].pixel_data;
    uint32_t bpp = numbers[value].bytes_per_pixel;
    uint32_t num_width = numbers[value].width;
    uint32_t num_height = numbers[value].height;

    uint32_t fps_text_size = p_input->hstride * 4 * fps_text.height;
    uint32_t digit_size = p_input->hstride * 4 * (p_input->vsize-fps_text.height)/NUM_COUNT;
    uint8_t * p_dest = ((uint8_t*)fb_foreground) + place * digit_size + fps_text_size;

    for(uint32_t y = 0; y<num_height; y++)
    {
        for(uint32_t h = 0; h < num_width*bpp; h+=bpp)
        {
            p_dest[0] = p_src[h+2]; // B
            p_dest[1] = p_src[h+1]; // G
            p_dest[2] = p_src[h];   // R
            p_dest[3] = 0;          // A (Unused)
            p_dest+=4;
        }
    p_dest += ((p_input->hstride - p_input->hsize) * 4); // To beginning of next line
    p_src += num_width*bpp;
    }
}



/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }

}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 *  @brief       This function handles errors, closes all opened modules, and prints errors.
 *
 *  @param[in]   err       error status
 *  @param[in]   err_str   error string
 *  @retval      None
 **********************************************************************************************************************/
void handle_error (fsp_err_t err,  const char * err_str)
{
    if(FSP_SUCCESS != err)
    {
        /* Print the error */
        APP_ERR_PRINT(err_str);

        /* Close opened MIPI_DSI module*/
        if(RESET_VALUE != g_mipi_dsi0_ctrl.open)
        {
            if(FSP_SUCCESS != R_MIPI_DSI_Close (&g_mipi_dsi0_ctrl))
            {
                APP_ERR_PRINT("MIPI DSI Close API failed\r\n");
            }
        }

        /* Close opened GLCD module*/
        if(RESET_VALUE != g_display_ctrl.state)
        {
            if(FSP_SUCCESS != R_GLCDC_Close (&g_display_ctrl))
            {
                APP_ERR_PRINT("GLCDC Close API failed\r\n");
            }
        }

        /* Close opened ICU module*/
        if(RESET_VALUE != g_touch_external_irq_ctrl.open)
        {
            if(FSP_SUCCESS != R_ICU_ExternalIrqClose (&g_touch_external_irq_ctrl))
            {
                APP_ERR_PRINT("ICU ExternalIrqClose API failed\r\n");
            }
        }

        /* Close opened IIC master module*/
        if(RESET_VALUE != g_i2c_master_ctrl.open)
        {
            if(FSP_SUCCESS != R_IIC_MASTER_Close(&g_i2c_master_ctrl))
            {
                APP_ERR_PRINT("IIC MASTER Close API failed\r\n");
            }
        }

        /* Close opened CEU module*/
        if(0U != g_ceu_vga_ctrl.open)
        {
            if(FSP_SUCCESS != R_CEU_Close(&g_ceu_vga_ctrl))
            {
                APP_ERR_PRINT("R_CEU_Close FAILED\r\n");
            }
        }

        APP_ERR_TRAP(err);
    }
}
